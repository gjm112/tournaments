---
title: "Simulations"
format: html
editor: visual
---

```{r}
library(tidyverse)
library(combinat)
library(ggplot2)
library(future)
library(future.apply)
library(progressr)

# Use all cores except one
cl <- parallel::makeCluster(parallel::detectCores() - 2)
plan(cluster, workers = cl)


teams <- 16
```

Note: The naming of each data frame has the following structure: tournament_distribution_ties_r_info

-   tournament is the tournament structure
-   distribution is the name of the distribution for $\theta$ (Normal, Uniform, Same, Manual)
    -   Same is equal strengths or coin flip

    -   Manual is an user created $\theta$ vector passed by adding theta_hat = *user input* at the end of the function
-   ties: ties or noTies
-   r is the number of games in a series or the number of iterations of round robin or group stage
-   info is any additional information like reseeded, third place game, or bad seeding structure

# Getting Simulations

## Single Elimination

```{r}
single_elimination_param_grid <- expand.grid( 
  distribution = c("Normal","Uniform", "Same", "Exponential"), 
  ties = c(FALSE, TRUE), 
  series = c(1, 3, 7), 
  third_place = c(FALSE, TRUE), 
  reseeded = c(FALSE, TRUE), 
  bad_seeding_structure = c(FALSE, TRUE) 
  )

single_elimination_run_sim_block <- function(
  teams, distribution, ties, series, third_place, reseeded,
  bad_seeding_structure, p_block) {
  
  # Apply seeding structure rule
  seeding_structure <- if (bad_seeding_structure) 1:16 else NULL
  
  # Build the key
  parts <- c(
  "singleElimination",
  tolower(distribution),
  ifelse(ties, "ties", "noTies"),
  paste0(series),
  if (third_place) "thirdplace",
  if (reseeded) "reseeded",
  if (bad_seeding_structure) "badseed"
  )

  key <- paste(parts, collapse = "_")
  
  # Run the 100,000 tournament sims in parallel
  sim_list <- future_lapply(
    X = 1:100000,
    FUN = function(rep) {
      simulate_single_elimination_tournament(
        num_teams = teams,
        distribution = distribution,
        ties = ties,
        series = series,
        third_place = third_place,
        reseeded = reseeded,
        seeding_structure = seeding_structure
      )
    },
    future.seed = TRUE   # parallel-safe RNG
  )
  
  # Bind the simulation output
  final_df <- do.call(rbind, sim_list)
  final_df$teams <- teams
  
  assign(key, final_df, envir = .GlobalEnv)
  
  # Update outer progress bar
  p_block()
  
  message("Finished: ", key)
}

with_progress({
  p_block <- progressor(steps = nrow(single_elimination_param_grid))
  for (i in seq_len(nrow(single_elimination_param_grid))) {
    row <- single_elimination_param_grid[i, ]
    
    single_elimination_run_sim_block(
      teams        = teams,
      distribution = row$distribution,
      ties         = row$ties,
      series       = row$series,
      third_place  = row$third_place,
      reseeded     = row$reseeded,
      bad_seeding_structure = row$bad_seeding_structure,
      p_block      = p_block
    )
  }
})


```

## Double Elimination

```{r}
double_elimination_param_grid <- expand.grid( 
  distribution = c("Normal","Uniform", "Same", "Exponential"), 
  ties = c(FALSE, TRUE), 
  series = c(1, 3, 7), 
  final = c(FALSE, TRUE), 
  bad_seeding_structure = c(FALSE, TRUE) 
  )

double_elimination_run_sim_block <- function(
  teams, distribution, ties, series, final, bad_seeding_structure, p_block) {
  
  # Apply bad seeding structure override if required
  seeding_structure <- if (bad_seeding_structure) 1:16 else NULL
  
  # Build key
    # Build the key
  parts <- c(
    "doubleElimination",
    tolower(distribution),
    ifelse(ties, "ties", "noTies"),
    paste0(series),
    if (!final) "consolation",
    if (bad_seeding_structure) "badseed"
  )

  key <- paste(parts, collapse = "_")
  
  # Run 100,000 simulations in parallel
  sim_list <- future_lapply(
    X = 1:100000,
    FUN = function(rep) {
      simulate_double_elimination_tournament(
        num_teams = teams,
        distribution = distribution,
        ties = ties,
        series = series,
        final = final,
        seeding_structure = seeding_structure
      )
    },
    future.seed = TRUE    # ensures parallel RNG is valid
  )
  
  final_df <- do.call(rbind, sim_list)
  final_df$teams <- teams
  
  assign(key, final_df, envir = .GlobalEnv)
  
  # UPDATE BLOCK-LEVEL PROGRESS BAR
  p_block()
  
  message("Finished: ", key)
}


with_progress({
  p_block <- progressor(steps = nrow(double_elimination_param_grid))
  
  for (i in seq_len(nrow(double_elimination_param_grid))) {
    row <- double_elimination_param_grid[i, ]
    
    double_elimination_run_sim_block(
      teams        = teams,
      distribution = row$distribution,
      ties         = row$ties,
      series       = row$series,
      final        = row$final,
      bad_seeding_structure = row$bad_seeding_structure,
      p_block = p_block
    )
  }
})

```

## Round Robin

```{r}
round_robin_param_grid <- expand.grid( 
  distribution = c("Normal","Uniform", "Same", "Exponential"), 
  ties = c(FALSE, TRUE), 
  r = c(1,2,4)
  )

round_robin_run_sim_block <- function(
  teams, distribution, ties, r, p_block) {

  # Build key
    # Build the key
  parts <- c(
    "roundRobin",
    tolower(distribution),
    ifelse(ties, "ties", "noTies"),
    paste0(r)
  )

  key <- paste(parts, collapse = "_")
  
  # Run 100,000 simulations in parallel
  sim_list <- future_lapply(
    X = 1:1000000,
    FUN = function(rep) {
      simulate_roundrobin_r(
        num_teams = teams,
        distribution = distribution,
        ties = ties,
        r = r
      )
    },
    future.seed = TRUE    # ensures parallel RNG is valid
  )
  
  final_df <- do.call(rbind, sim_list)
  final_df$teams <- teams
  
  assign(key, final_df, envir = .GlobalEnv)
  
  # UPDATE BLOCK-LEVEL PROGRESS BAR
  p_block()
  
  message("Finished: ", key)
}


with_progress({
  p_block <- progressor(steps = nrow(round_robin_param_grid))
  
  for (i in seq_len(nrow(round_robin_param_grid))) {
    row <- round_robin_param_grid[i, ]
    
    round_robin_run_sim_block(
      teams        = teams,
      distribution = row$distribution,
      ties         = row$ties,
      r            = row$r,
      p_block = p_block
    )
  }
})
```

## Group Stage

```{r}
# Group stage is currently set so only the top 2 in each group advance
group_stage_param_grid <- expand.grid( 
  distribution = c("Normal","Uniform", "Same", "Exponential"), 
  ties = c(FALSE, TRUE), 
  rounds = c(1,2,4),
  group_length = c(4,8)
  )

group_stage_run_sim_block <- function(
  teams, distribution, ties, rounds, group_length, p_block) {

  # Build key
    # Build the key
  parts <- c(
    "groupStage",
    tolower(distribution),
    ifelse(ties, "ties", "noTies"),
    paste0(rounds),
    paste0(group_length, "groups")
  )

  key <- paste(parts, collapse = "_")
  
  # Run 100,000 simulations in parallel
  sim_list <- future_lapply(
    X = 1:100000,
    FUN = function(rep) {
      simulate_group_stage_tournament(
        num_teams = teams,
        distribution = distribution,
        ties = ties,
        rounds = rounds,
        group_length = group_length
      )
    },
    future.seed = TRUE    # ensures parallel RNG is valid
  )
  
  final_df <- do.call(rbind, sim_list)
  final_df$teams <- teams
  
  assign(key, final_df, envir = .GlobalEnv)
  
  # UPDATE BLOCK-LEVEL PROGRESS BAR
  p_block()
  
  message("Finished: ", key)
}


with_progress({
  p_block <- progressor(steps = nrow(group_stage_param_grid))
  
  for (i in seq_len(nrow(group_stage_param_grid))) {
    row <- group_stage_param_grid[i, ]
    
    group_stage_run_sim_block(
      teams        = teams,
      distribution = row$distribution,
      ties         = row$ties,
      rounds       = row$rounds,
      group_length = row$group_length,
      p_block = p_block
    )
  }
})

```

## Waterfall

## Step Ladder

```{r}
stepLadder_param_grid <- expand.grid( 
  distribution = c("Normal","Uniform", "Same", "Exponential"), 
  series = c(1, 3, 7), 
  bad_seeding_structure = c(FALSE, TRUE) 
  )

stepLadder_run_sim_block <- function(
  teams, distribution, bad_seeding_structure, series, p_block) {
  
  # Apply bad seeding structure override if required
  seeding_structure <- if (bad_seeding_structure) 1:16 else NULL

  # Build key
    # Build the key
  parts <- c(
    "stepLadder",
    tolower(distribution),
    paste0(series),
    if (bad_seeding_structure) "badseed"
    
  )

  key <- paste(parts, collapse = "_")
  
  # Run 100,000 simulations in parallel
  sim_list <- future_lapply(
    X = 1:100000,
    FUN = function(rep) {
      simulate_step_ladder(
        num_teams = teams,
        distribution = distribution,
        series = series,
        seeding_structure = seeding_structure
      )
    },
    future.seed = TRUE    # ensures parallel RNG is valid
  )
  
  final_df <- do.call(rbind, sim_list)
  final_df$teams <- teams
  
  assign(key, final_df, envir = .GlobalEnv)
  
  # UPDATE BLOCK-LEVEL PROGRESS BAR
  p_block()
  
  message("Finished: ", key)
}


with_progress({
  p_block <- progressor(steps = nrow(stepLadder_param_grid))
  
  for (i in seq_len(nrow(stepLadder_param_grid))) {
    row <- stepLadder_param_grid[i, ]
    
    stepLadder_run_sim_block(
      teams        = teams,
      distribution = row$distribution,
      series       = row$series,
      bad_seeding_structure = row$bad_seeding_structure,
      p_block = p_block
    )
  }
})
```

## Staged Round Robin

## High School Tennis Ladder

# Getting Mutual Information

### Functions to get MI and put it in a Data Frame for Plots

```{r}
library(ggsci)
compute_mi_for_datasets <- function(dataset_list) {
  # Validate input
  if (!is.list(dataset_list)) {
    stop("dataset_list must be a list of data frames")
  }
  
  # Get dataset names from the list
  if (!is.null(names(dataset_list)) && all(names(dataset_list) != "")) {
    dataset_names <- names(dataset_list)
  } else {
    dataset_names <- paste0("Dataset_", seq_along(dataset_list))
  }
  
  # Helper function to add simulation number if needed
  add_simulation_number <- function(df) {
    if (!"simulation" %in% colnames(df)) {
      n_rows <- nrow(df)
      n_sims <- 10000
      rows_per_sim <- round(n_rows / n_sims)
      
      # Memory efficient: create simulation numbers
      df$simulation <- rep(1:n_sims, each = rows_per_sim)
    }
    return(df)
  }
  
  # Compute MI for all datasets and store as list column
  mi_list <- lapply(seq_along(dataset_list), function(i) {
    df <- dataset_list[[i]]
    df <- add_simulation_number(df)
    
    # Compute MI - returns a vector or dataframe
    result <- compute_mut_plots(df)
    
    # Convert to vector if it's a dataframe
    if (is.data.frame(result)) {
      result <- unlist(result)
    }
    
    return(result)
  })
  
  # Return dataframe with list column
  data.frame(
    dataset = dataset_names,
    stringsAsFactors = FALSE
  ) %>%
    mutate(mi = mi_list)
}

# Example usage:
#mi_ex <- compute_mi_for_datasets(list(
#   singleElimination_normal_noTies_1,
#   singleElimination_normal_noTies_1_badseed
# ))


compute_mi_combinations_for_datasets <- function(dataset_list) {
  # Validate input
  if (!is.list(dataset_list)) {
    stop("dataset_list must be a list of data frames")
  }
  
  # Get dataset names from the list
  if (!is.null(names(dataset_list)) && all(names(dataset_list) != "")) {
    dataset_names <- names(dataset_list)
  } else {
    dataset_names <- paste0("Dataset_", seq_along(dataset_list))
  }
  
  # Helper function to add simulation number if needed
  add_simulation_number <- function(df) {
    if (!"simulation" %in% colnames(df)) {
      n_rows <- nrow(df)
      n_sims <- 10000
      rows_per_sim <- round(n_rows / n_sims)
      
      # Memory efficient: create simulation numbers
      df$simulation <- rep(1:n_sims, each = rows_per_sim)
    }
    return(df)
  }
  
  # Compute MI for all datasets and store as list column
  mi_list <- lapply(seq_along(dataset_list), function(i) {
    df <- dataset_list[[i]]
    df <- add_simulation_number(df)
    
    # Compute MI - returns a vector or dataframe
    result <- compute_mut_plots_combinations(df)
    
    # Convert to vector if it's a dataframe
    if (is.data.frame(result)) {
      result <- unlist(result)
    }
    
    return(result)
  })
  
  # Return dataframe with list column
  data.frame(
    dataset = dataset_names,
    stringsAsFactors = FALSE
  ) %>%
    mutate(mi = mi_list)
}
 

plot_mi <- function(mi_results, dataset_names = NULL) {
  # If no dataset names specified, plot all datasets
  if (is.null(dataset_names)) {
    dataset_names <- mi_results$dataset
  }
  
  # Filter to only requested datasets
  filtered_results <- mi_results %>%
    filter(dataset %in% dataset_names)
  
  if (nrow(filtered_results) == 0) {
    stop("No matching datasets found in results.")
  }
  
  # Convert list column to long format for plotting
  plot_df <- filtered_results %>%
    rowwise() %>%
    mutate(
      index = list(1:length(mi)),
      mi_values = list(mi)
    ) %>%
    unnest(cols = c(index, mi_values)) %>%
    ungroup()
  
  return(plot_df)
}
```

### Getting MI for All Structures

```{r}
compute_and_store_mi_by_tournament <- function(tournament_structure) {
  
  # Validate input
  valid_structures <- c("singleElimination", "doubleElimination", "roundRobin", "groupStage", "stepLadder")
  if (!tournament_structure %in% valid_structures) {
    stop(paste("Invalid tournament_structure. Must be one of:", 
               paste(valid_structures, collapse = ", ")))
  }
  
  # Helper function to collect datasets for a specific tournament type
  collect_tournament_datasets <- function(param_grid, tournament_type, key_builder) {
    dataset_list <- list()
    
    for (i in seq_len(nrow(param_grid))) {
      row <- param_grid[i, ]
      parts <- key_builder(row, tournament_type)
      key <- paste(parts, collapse = "_")
      
      if (exists(key, envir = .GlobalEnv)) {
        dataset_list[[key]] <- get(key, envir = .GlobalEnv)
      } else {
        warning(paste("Dataset not found:", key))
      }
    }
    
    return(dataset_list)
  }
  
  # Key builders for each tournament type
  single_elim_key <- function(row, type) {
    c(
      type,
      tolower(row$distribution),
      ifelse(row$ties, "ties", "noTies"),
      paste0(row$series),
      if (row$third_place) "thirdplace",
      if (row$reseeded) "reseeded",
      if (row$bad_seeding_structure) "badseed"
    )
  }
  
  double_elim_key <- function(row, type) {
    c(
      type,
      tolower(row$distribution),
      ifelse(row$ties, "ties", "noTies"),
      paste0(row$series),
      if (!row$final) "consolation",
      if (row$bad_seeding_structure) "badseed"
    )
  }
  
  round_robin_key <- function(row, type) {
    c(
      type,
      tolower(row$distribution),
      ifelse(row$ties, "ties", "noTies"),
      paste0(row$r)
    )
  }
  
  group_stage_key <- function(row, type) {
    c(
      type,
      tolower(row$distribution),
      ifelse(row$ties, "ties", "noTies"),
      paste0(row$rounds),
      paste0(row$group_length, "groups")
    )
  }
  
   stepLadder_key <- function(row, type) {
    c(
    type,
    tolower(row$distribution),
    paste0(row$series),
    if (row$bad_seeding_structure) "badseed"
    )
   }
   
  
  # Function to process a single tournament type
  process_tournament_type <- function(type_name, param_grid, key_builder) {
    message(paste("Collecting", type_name, "datasets..."))
    datasets <- collect_tournament_datasets(param_grid, type_name, key_builder)
    
    message(paste("Computing MI for", type_name, "..."))
    mi_results <- compute_mi_for_datasets(datasets)
    
    message(paste("Computing MI combinations for", type_name, "..."))
    mi_combinations_results <- compute_mi_combinations_for_datasets(datasets)
    
    # Store in global environment
    mi_var_name <- paste0(type_name, "_mi")
    assign(mi_var_name, mi_results, envir = .GlobalEnv)
    
    mi_combinations_var_name <- paste0(type_name, "_combinations_mi")
    assign(mi_combinations_var_name, mi_combinations_results, envir = .GlobalEnv)
    
    # Create summary
    summary_df <- data.frame(
      dataset = names(mi_results),
      mi = mi_results,
      mi_combinations = mi_combinations_results,
      stringsAsFactors = FALSE
    )
    
    message(paste("- Created", mi_var_name, "with", length(mi_results), "datasets"))
    message(paste("- Created", mi_combinations_var_name, "with", length(mi_combinations_results), "datasets"))
    
    return(list(mi = mi_results, mi_combinations = mi_combinations_results, summary = summary_df))
  }
  
  # Process based on tournament_structure input
  results_list <- list()
  summary_list <- list()
  
  if (tournament_structure %in% c("singleElimination")) {
    result <- process_tournament_type("singleElimination", 
                                      single_elimination_param_grid, 
                                      single_elim_key)
    results_list$singleElimination <- result
  }
  
  if (tournament_structure %in% c("doubleElimination")) {
    result <- process_tournament_type("doubleElimination", 
                                      double_elimination_param_grid, 
                                      double_elim_key)
    results_list$doubleElimination <- result
  }
  
  if (tournament_structure %in% c("roundRobin")) {
    result <- process_tournament_type("roundRobin", 
                                      round_robin_param_grid, 
                                      round_robin_key)
    results_list$roundRobin <- result
  }
  
  if (tournament_structure %in% c("groupStage")) {
    result <- process_tournament_type("groupStage", 
                                      group_stage_param_grid, 
                                      group_stage_key)
    results_list$groupStage <- result
  }
   if (tournament_structure %in% c("stepLadder")) {
    result <- process_tournament_type("stepLadder", 
                                      stepLadder_param_grid, 
                                      stepLadder_key)
    results_list$stepLadder <- result
  }
  
  message("\nâœ“ MI computation complete!")
  
  # Return a list of all results (optional)
  invisible(results_list)
}

compute_and_store_mi_by_tournament("singleElimination")
compute_and_store_mi_by_tournament("doubleElimination")
compute_and_store_mi_by_tournament("roundRobin")
compute_and_store_mi_by_tournament("groupStage")
compute_and_store_mi_by_tournament("stepLadder")

all_mi <- bind_rows(
  singleElimination_mi,
  doubleElimination_mi,
  groupStage_mi,
  roundRobin_mi,
  stepLadder_mi
)
```

# MI Plots

```{r}
library(ggsci)
```

## Comparison Plot

```{r}
combined_plot_df <- plot_mi(all_mi, c(
  "singleElimination_normal_noTies_1",
  "singleElimination_uniform_noTies_1", 
  "singleElimination_same_noTies_1", 
  #"singleElimination_exponential_noTies_1",
  "doubleElimination_normal_noTies_1", 
  "doubleElimination_uniform_noTies_1",
  "doubleElimination_same_noTies_1", 
  #"doubleElimination_exponential_noTies_1", 
  "roundRobin_normal_noTies_1", 
  "roundRobin_uniform_noTies_1", 
  "roundRobin_same_noTies_1", 
  #"roundRobin_exponential_noTies_1", 
  "groupStage_normal_noTies_1_4groups",
  "groupStage_uniform_noTies_1_4groups",
  "groupStage_same_noTies_1_4groups"#,
  #"groupStage_exponential_noTies_1_4groups"
  )
)

parse_dataset_name_combined <- function(dataset_name) {
  parts <- str_split(dataset_name, "_")[[1]]
  
  # Extract tournament type (first part)
  tournament_type <- parts[1]
  
  # Extract distribution (second part)
  distribution <- parts[2]
  distribution <- str_to_title(distribution)
  
  # default group length
  group_length <- NA
  
  if(tournament_type == "groupStage"){
    group_length <- as.numeric(str_extract(parts[5], "\\d+"))
    }
  
  return(data.frame(
    tournament_type = tournament_type,
    distribution = distribution,
    group_length = group_length
  ))
}

combined_plot_df <- combined_plot_df %>%
  select(-any_of(c("tournament_type", "distribution", "group_length"))) %>%
  group_by(dataset) %>%
  mutate(
    params = list(parse_dataset_name_combined(dataset[1]))
  ) %>%
  unnest(params) %>%
  ungroup() %>%
  mutate(
    # Create a label for the additional parameters
    param_label = paste(tournament_type, sep = "\n")
  )

combined_plot_df <- combined_plot_df %>%
  mutate(
    color_group = case_when(
      tournament_type == "groupStage" ~ "groupStage (4 Groups)",
      TRUE ~ tournament_type
    )
  )

combined_plot <- ggplot(combined_plot_df, aes(x = index, y = mi_values, color = color_group, group = dataset)) +
  geom_line(linewidth = 1) +
  geom_point(size = 1.5) +
  facet_grid(
    ~ distribution,
    labeller = labeller(
      distribution = function(x) x
    )
  ) +
  labs(
    title = "Mutual Information (No Ties)",
    x = "Top K Teams",
    y = "Mutual Information (MI)"
  ) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
  scale_x_continuous(breaks = 1:16) + 
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 11),
    axis.text = element_text(size = 8),
    strip.text = element_text(size = 10, face = "bold"),
    legend.position = "bottom", 
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 7),
    panel.spacing = unit(1, "lines")
  ) +
  scale_color_d3("category20") +
  guides(color = guide_legend(nrow = 2))

print(combined_plot)
```

## Single Elimination

```{r}
single_elimination_plot_df <- bind_rows(
  plot_mi(singleElimination_mi),
  plot_mi(stepLadder_mi)
)

# Parse dataset names to extract parameters
parse_dataset_name_se <- function(dataset_name) {
  parts <- str_split(dataset_name, "_")[[1]]
  
  # Extract tournament type (first part)
  tournament_type <- parts[1]
  
  # Extract distribution (second part)
  distribution <- parts[2]
  distribution <- str_to_title(distribution)
  
  if (tournament_type == "singleElimination") {
    # Extract ties (third part)
    ties <- ifelse(parts[3] == "ties", "Ties", "No Ties")
    
    # Extract series (fourth part - just the number)
    series <- as.numeric(parts[4])
    
    # Check for third_place (could be in position 5+)
    third_place <- ifelse(any(parts == "thirdplace"), "Third Place", "No Third Place")
    
    # Check for reseeded
    reseeded <- ifelse(any(parts == "reseeded"), "Reseeded", "Not Reseeded")
    
    # Check for badseed
    bad_seeding <- ifelse(any(parts == "badseed"), "Bad Seed", "Good Seed")
  } else if (tournament_type == "stepLadder") {
    # Step ladder doesn't have ties parameter
    ties <- "No Ties"  # Default for step ladder
    
    # Extract series (third part for step ladder)
    series <- as.numeric(parts[3])
    
    # Step ladder specific defaults
    third_place <- "No Third Place"
    reseeded <- "Not Reseeded"
    
    # Check for badseed
    bad_seeding <- ifelse(any(parts == "badseed"), "Bad Seed", "Good Seed")
  }
  
  return(data.frame(
    tournament_type = tournament_type,
    distribution = distribution,
    ties = ties,
    series = series,
    third_place = third_place,
    reseeded = reseeded,
    bad_seeding = bad_seeding
  ))
}

# Add parameter columns to the plot data
single_elimination_plot_df <- single_elimination_plot_df %>%
  select(-any_of(c("tournament_type", "distribution", "ties", "series", "third_place", "reseeded", "bad_seeding", "param_label", "color_group"))) %>%
  group_by(dataset) %>%
  mutate(
    params = list(parse_dataset_name_se(dataset[1]))
  ) %>%
  unnest(params) %>%
  ungroup() %>%
   filter(third_place == "Third Place" | tournament_type == "stepLadder") %>% 
  mutate(
    series = factor(series, levels = c(1, 3, 7)),
    # Create a label for the additional parameters
    param_label = paste(tournament_type, reseeded, bad_seeding, sep = "\n")
  )

# Create a consistent color variable based on the parameter combinations
single_elimination_plot_df <- single_elimination_plot_df %>%
  mutate(
    color_group = paste(tournament_type, reseeded, bad_seeding, sep = " | ")
  )

# Filter data for No Ties
single_elim_noties_df <- single_elimination_plot_df %>%
  filter(ties == "No Ties")

# Filter data for Ties
single_elim_ties_df <- single_elimination_plot_df %>%
  filter(ties == "Ties")

# Plot 1: No Ties
single_elimination_noties_plot <- ggplot(single_elim_noties_df, aes(x = index, y = mi_values, color = color_group, group = dataset)) +
  geom_line(linewidth = 1) +
  geom_point(size = 1.5) +
  facet_grid(
    series ~ distribution,
    labeller = labeller(
      series = function(x) paste("Series:", x),
      distribution = function(x) x
    )
  ) +
  labs(
    title = "Single Elimination: Mutual Information (No Ties)",
    x = "Top K Teams",
    y = "Mutual Information (MI)",
    color = "Parameters"
  ) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
  scale_x_continuous(breaks = 1:16) + 
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 11),
    axis.text = element_text(size = 8),
    strip.text = element_text(size = 10, face = "bold"),
    legend.position = "bottom", 
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 7),
    panel.spacing = unit(1, "lines")
  ) +
  scale_color_d3("category20") +
  guides(color = guide_legend(nrow = 2))

# Plot 2: Ties
single_elimination_ties_plot <- ggplot(single_elim_ties_df, aes(x = index, y = mi_values, color = color_group, group = dataset)) +
  geom_line(linewidth = 1) +
  geom_point(size = 1.5) +
  facet_grid(
    series ~ distribution,
    labeller = labeller(
      series = function(x) paste("Series:", x),
      distribution = function(x) x
    )
  ) +
  labs(
    title = "Single Elimination: Mutual Information (Ties)",
    x = "Top K Teams",
    y = "Mutual Information (MI)",
    color = "Parameters"
  ) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
  scale_x_continuous(breaks = 1:16) + 
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 11),
    axis.text = element_text(size = 8),
    strip.text = element_text(size = 10, face = "bold"),
    legend.position = "bottom", 
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 7),
    panel.spacing = unit(1, "lines")
  ) +
  scale_color_d3("category20") +
  guides(color = guide_legend(nrow = 2))

# Display plots
print(single_elimination_noties_plot)
print(single_elimination_ties_plot)
```

## Double Elimination

```{r}
double_elimination_plot_df <- plot_mi(doubleElimination_mi)

# Parse dataset names to extract parameters
parse_dataset_name <- function(dataset_name) {
  parts <- str_split(dataset_name, "_")[[1]]
  
  # Extract distribution (second part)
  distribution <- parts[2]
  distribution <- str_to_title(distribution)
  
  # Extract ties (third part)
  ties <- ifelse(parts[3] == "ties", "Ties", "No Ties")
  
  # Extract series (fourth part - just the number)
  series <- as.numeric(parts[4])
  
  # Check for consolation (fifth part might be "consolation")
  #final <- ifelse(length(parts) >= 5 && parts[5] == "consolation", "Consolation", "Final")
  
  # Check for badseed (could be fifth or sixth part)
  bad_seeding <- ifelse(any(parts == "badseed"), "Bad Seed", "Good Seed")
  
  return(data.frame(
    distribution = distribution,
    ties = ties,
    series = series,
    #final = final,
    bad_seeding = bad_seeding
  ))
}

# Add parameter columns to the plot data
double_elimination_plot_df <- double_elimination_plot_df %>%
  group_by(dataset) %>%
  mutate(
    params = list(parse_dataset_name(dataset[1]))
  ) %>%
  unnest(params) %>%
  ungroup() %>%
  mutate(
    series = factor(series, levels = c(1, 3, 7)),
    # Create a label for the additional parameters
    param_label = paste(bad_seeding, sep = "\n")
  )

# Create a consistent color variable based on the parameter combinations
double_elimination_plot_df <- double_elimination_plot_df %>%
  mutate(
    color_group = paste(bad_seeding, sep = " | ")
  )

# Filter data for No Ties
double_elimination_plot_noTies_df <- double_elimination_plot_df %>%
  filter(ties == "No Ties")

# Filter data for Ties
double_elimination_plot_ties_df <- double_elimination_plot_df %>%
  filter(ties == "Ties")

# Plot 1: No Ties
double_elimination_noties_plot <- ggplot(double_elimination_plot_noTies_df, aes(x = index, y = mi_values, color = color_group, group = dataset)) +
  geom_line(linewidth = 1) +
  geom_point(size = 1.5) +
  facet_grid(
    series ~ distribution,
    labeller = labeller(
      series = function(x) paste("Rounds:", x),
      distribution = function(x) x
    )
  ) +
  labs(
    title = "Double Elimination: Mutual Information (No Ties)",
    x = "Top K Teams",
    y = "Mutual Information (MI)",
    color = "Seeding"
  ) +
  scale_y_continuous(limits = c(0.25, 1), breaks = seq(0, 1, 0.2)) +
  scale_x_continuous(breaks = 1:16) + 
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 11),
    axis.text = element_text(size = 8),
    strip.text = element_text(size = 10, face = "bold"),
    legend.position = "bottom", 
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 8),
    panel.spacing = unit(1, "lines")
  ) +
  scale_color_d3("category20") +
  guides(color = guide_legend(nrow = 1))

# Plot 2: Ties
double_elimination_ties_plot <- ggplot(double_elimination_plot_ties_df, aes(x = index, y = mi_values, color = color_group, group = dataset)) +
  geom_line(linewidth = 1) +
  geom_point(size = 1.5) +
  facet_grid(
    series ~ distribution,
    labeller = labeller(
      series = function(x) paste("Rounds:", x),
      distribution = function(x) x
    )
  ) +
  labs(
    title = "Double Elimination: Mutual Information (Ties)",
    x = "Top K Teams",
    y = "Mutual Information (MI)",
    color = "Seeding"
  ) +
  scale_y_continuous(limits = c(0.25, 1), breaks = seq(0, 1, 0.2)) +
  scale_x_continuous(breaks = 1:16) + 
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 11),
    axis.text = element_text(size = 8),
    strip.text = element_text(size = 10, face = "bold"),
    legend.position = "bottom", 
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 8),
    panel.spacing = unit(1, "lines")
  ) +
  scale_color_d3("category20") +
  guides(color = guide_legend(nrow = 1))

# Display plots
print(double_elimination_noties_plot)
print(double_elimination_ties_plot)

```

## Round Robin

```{r}
roundRobin_plot_df <- plot_mi(roundRobin_mi)

# Parse dataset names to extract parameters
parse_dataset_name <- function(dataset_name) {
  parts <- str_split(dataset_name, "_")[[1]]
  
  # Extract distribution (second part)
  distribution <- parts[2]
  distribution <- str_to_title(distribution)
  
  # Extract ties (third part)
  ties <- ifelse(parts[3] == "ties", "Ties", "No Ties")
  
  # Extract series (fourth part - just the number)
  rounds <- as.numeric(parts[4])
  
  return(data.frame(
    distribution = distribution,
    ties = ties,
    rounds = rounds
  ))
}

# Add parameter columns to the plot data
roundRobin_plot_df <- roundRobin_plot_df %>%
  group_by(dataset) %>%
  mutate(
    params = list(parse_dataset_name(dataset[1]))
  ) %>%
  unnest(params) %>%
  ungroup() %>%
  mutate(
    series = factor(rounds, levels = c(1, 2, 4)),
  )

# Filter data for No Ties
roundRobin_plot_noties_df <- roundRobin_plot_df %>%
  filter(ties == "No Ties")

# Filter data for Ties
roundRobin_plot_ties_df <- roundRobin_plot_df %>%
  filter(ties == "Ties")

# Plot 1: No Ties
roundRobin_noties_plot <- ggplot(roundRobin_plot_noties_df, aes(x = index, y = mi_values, group = dataset)) +
  geom_line(linewidth = 1) +
  geom_point(size = 1.5) +
  facet_grid(
    series ~ distribution,
    labeller = labeller(
      series = function(x) paste("Rounds:", x),
      distribution = function(x) x
    )
  ) +
  labs(
    title = "Round Robin: Mutual Information (No Ties)",
    x = "Top K Teams",
    y = "Mutual Information (MI)"
  ) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
  scale_x_continuous(breaks = 1:16) + 
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 11),
    axis.text = element_text(size = 8),
    strip.text = element_text(size = 10, face = "bold"),
    legend.position = "bottom", 
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 8),
    panel.spacing = unit(1, "lines")
  ) +
  scale_color_d3("category20")

# Plot 2: Ties
roundRobin_ties_plot <- ggplot(roundRobin_plot_ties_df, aes(x = index, y = mi_values, group = dataset)) +
  geom_line(linewidth = 1) +
  geom_point(size = 1.5) +
  facet_grid(
    series ~ distribution,
    labeller = labeller(
      series = function(x) paste("Rounds:", x),
      distribution = function(x) x
    )
  ) +
  labs(
    title = "Round Robin: Mutual Information (Ties)",
    x = "Top K Teams",
    y = "Mutual Information (MI)"
  ) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
  scale_x_continuous(breaks = 1:16) + 
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 11),
    axis.text = element_text(size = 8),
    strip.text = element_text(size = 10, face = "bold"),
    legend.position = "bottom", 
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 8),
    panel.spacing = unit(1, "lines")
  ) +
  scale_color_d3("category20")

# Display plots
print(roundRobin_noties_plot)
print(roundRobin_ties_plot)

```

## Group Stage

```{r}
group_stage_plot_df <- plot_mi(groupStage_mi)

# Parse dataset names to extract parameters
parse_dataset_name <- function(dataset_name) {
  parts <- str_split(dataset_name, "_")[[1]]
  
  # Extract distribution (second part)
  distribution <- parts[2]
  distribution <- str_to_title(distribution)
  
  # Extract ties (third part)
  ties <- ifelse(parts[3] == "ties", "Ties", "No Ties")
  
  # Extract series (fourth part - just the number)
  rounds <- as.numeric(parts[4])
  
  # Check for group length (fifth part)
  group_length <- as.numeric(str_extract(parts[5], "\\d+"))
  
  return(data.frame(
    distribution = distribution,
    ties = ties,
    rounds = rounds,
    group_length = group_length
  ))
}

# Add parameter columns to the plot data
group_stage_plot_df <- group_stage_plot_df %>%
  group_by(dataset) %>%
  mutate(
    params = list(parse_dataset_name(dataset[1]))
  ) %>%
  unnest(params) %>%
  ungroup() %>%
  mutate(
    series = factor(rounds, levels = c(1, 2, 4)),
    # Create a label for the additional parameters
    param_label = paste(group_length, sep = "\n")
  )

# Create a consistent color variable based on the parameter combinations
group_stage_plot_df <- group_stage_plot_df %>%
  mutate(
    color_group = paste(group_length, sep = " | ")
  )

# Filter data for No Ties
group_stage_noties_df <- group_stage_plot_df %>%
  filter(ties == "No Ties")

# Filter data for Ties
group_stage_ties_df <- group_stage_plot_df %>%
  filter(ties == "Ties")

# Plot 1: No Ties
group_stage_noties_plot <- ggplot(group_stage_noties_df, aes(x = index, y = mi_values, color = color_group, group = dataset)) +
  geom_line(linewidth = 1) +
  geom_point(size = 1.5) +
  facet_grid(
    series ~ distribution,
    labeller = labeller(
      series = function(x) paste("Rounds:", x),
      distribution = function(x) x
    )
  ) +
  labs(
    title = "Group Stage: Mutual Information (No Ties)",
    x = "Top K Teams",
    y = "Mutual Information (MI)",
    color = "Group Length:"
  ) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
  scale_x_continuous(breaks = 1:16) + 
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 11),
    axis.text = element_text(size = 8),
    strip.text = element_text(size = 10, face = "bold"),
    legend.position = "bottom", 
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 8),
    panel.spacing = unit(1, "lines")
  ) +
  scale_color_d3("category20") +
  guides(color = guide_legend(nrow = 1))

# Plot 2: Ties
group_stage_ties_plot <- ggplot(group_stage_ties_df, aes(x = index, y = mi_values, color = color_group, group = dataset)) +
  geom_line(linewidth = 1) +
  geom_point(size = 1.5) +
  facet_grid(
    series ~ distribution,
    labeller = labeller(
      series = function(x) paste("Rounds:", x),
      distribution = function(x) x
    )
  ) +
  labs(
    title = "Group Stage: Mutual Information (Ties)",
    x = "Top K Teams",
    y = "Mutual Information (MI)",
    color = "Group Length:"
  ) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
  scale_x_continuous(breaks = 1:16) + 
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 11),
    axis.text = element_text(size = 8),
    strip.text = element_text(size = 10, face = "bold"),
    legend.position = "bottom", 
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 8),
    panel.spacing = unit(1, "lines")
  ) +
  scale_color_d3("category20") +
  guides(color = guide_legend(nrow = 1))

# Display plots
print(group_stage_noties_plot)
print(group_stage_ties_plot)

```
