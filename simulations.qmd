---
title: "Simulations"
format: html
editor: visual
---

```{r}
library(tidyverse)
library(combinat)
library(ggplot2)
library(future)
library(future.apply)
library(progressr)

# Use all cores except one
cl <- parallel::makeCluster(parallel::detectCores() - 2)
plan(cluster, workers = cl)


teams <- 16
```

Note: The naming of each data frame has the following structure: tournament_distribution_ties_r_info

-   tournament is the tournament structure
-   distribution is the name of the distribution for $\theta$ (Normal, Uniform, Same, Manual)
    -   Same is equal strengths or coin flip

    -   Manual is an user created $\theta$ vector passed by adding theta_hat = *user input* at the end of the function
-   ties: ties or noTies
-   r is the number of games in a series or the number of iterations of round robin or group stage
-   info is any additional information like reseeded, third place game, or bad seeding structure

# Getting Simulations

## Single Elimination

```{r}
single_elimination_param_grid <- expand.grid( 
  distribution = c("Normal","Uniform", "Same"), 
  ties = c(FALSE, TRUE), 
  series = c(1, 3, 7), 
  third_place = c(FALSE, TRUE), 
  reseeded = c(FALSE, TRUE), 
  bad_seeding_structure = c(FALSE, TRUE) 
  )

single_elimination_run_sim_block <- function(
  teams, distribution, ties, series, third_place, reseeded,
  bad_seeding_structure, p_block) {
  
  # Apply seeding structure rule
  seeding_structure <- if (bad_seeding_structure) 1:16 else NULL
  
  # Build the key
  parts <- c(
  "singleElimination",
  tolower(distribution),
  ifelse(ties, "ties", "noTies"),
  paste0(series),
  if (third_place) "thirdplace",
  if (reseeded) "reseeded",
  if (bad_seeding_structure) "badseed"
  )

  key <- paste(parts, collapse = "_")
  
  # Run the 10,000 tournament sims in parallel
  sim_list <- future_lapply(
    X = 1:10000,
    FUN = function(rep) {
      simulate_single_elimination_tournament(
        num_teams = teams,
        distribution = distribution,
        ties = ties,
        series = series,
        third_place = third_place,
        reseeded = reseeded,
        seeding_structure = seeding_structure
      )
    },
    future.seed = TRUE   # parallel-safe RNG
  )
  
  # Bind the simulation output
  final_df <- do.call(rbind, sim_list)
  final_df$teams <- teams
  
  assign(key, final_df, envir = .GlobalEnv)
  
  # Update outer progress bar
  p_block()
  
  message("Finished: ", key)
}

with_progress({
  p_block <- progressor(steps = nrow(single_elimination_param_grid))
  for (i in seq_len(nrow(single_elimination_param_grid))) {
    row <- single_elimination_param_grid[i, ]
    
    single_elimination_run_sim_block(
      teams        = teams,
      distribution = row$distribution,
      ties         = row$ties,
      series       = row$series,
      third_place  = row$third_place,
      reseeded     = row$reseeded,
      bad_seeding_structure = row$bad_seeding_structure,
      p_block      = p_block
    )
  }
})


```

## Double Elimination

```{r}
double_elimination_param_grid <- expand.grid( 
  distribution = c("Normal","Uniform", "Same"), 
  ties = c(FALSE, TRUE), 
  series = c(1, 3, 7), 
  final = c(FALSE, TRUE), 
  bad_seeding_structure = c(FALSE, TRUE) 
  )

double_elimination_run_sim_block <- function(
  teams, distribution, ties, series, final, bad_seeding_structure, p_block) {
  
  # Apply bad seeding structure override if required
  seeding_structure <- if (bad_seeding_structure) 1:16 else NULL
  
  # Build key
    # Build the key
  parts <- c(
    "doubleElimination",
    tolower(distribution),
    ifelse(ties, "ties", "noTies"),
    paste0(series),
    if (!final) "consolation",
    if (bad_seeding_structure) "badseed"
  )

  key <- paste(parts, collapse = "_")
  
  # Run 10,000 simulations in parallel
  sim_list <- future_lapply(
    X = 1:10000,
    FUN = function(rep) {
      simulate_double_elimination_tournament(
        num_teams = teams,
        distribution = distribution,
        ties = ties,
        series = series,
        final = final,
        seeding_structure = seeding_structure
      )
    },
    future.seed = TRUE    # ensures parallel RNG is valid
  )
  
  final_df <- do.call(rbind, sim_list)
  final_df$teams <- teams
  
  assign(key, final_df, envir = .GlobalEnv)
  
  # UPDATE BLOCK-LEVEL PROGRESS BAR
  p_block()
  
  message("Finished: ", key)
}


with_progress({
  p_block <- progressor(steps = nrow(double_elimination_param_grid))
  
  for (i in seq_len(nrow(double_elimination_param_grid))) {
    row <- double_elimination_param_grid[i, ]
    
    double_elimination_run_sim_block(
      teams        = teams,
      distribution = row$distribution,
      ties         = row$ties,
      series       = row$series,
      final        = row$final,
      bad_seeding_structure = row$bad_seeding_structure,
      p_block = p_block
    )
  }
})

```

## Round Robin

```{r}
round_robin_param_grid <- expand.grid( 
  distribution = c("Normal","Uniform", "Same"), 
  ties = c(FALSE, TRUE), 
  r = c(1,2,4)
  )

round_robin_run_sim_block <- function(
  teams, distribution, ties, r, p_block) {

  # Build key
    # Build the key
  parts <- c(
    "roundRobin",
    tolower(distribution),
    ifelse(ties, "ties", "noTies"),
    paste0(r)
  )

  key <- paste(parts, collapse = "_")
  
  # Run 10,000 simulations in parallel
  sim_list <- future_lapply(
    X = 1:10000,
    FUN = function(rep) {
      simulate_roundrobin_r(
        num_teams = teams,
        distribution = distribution,
        ties = ties,
        r = r
      )
    },
    future.seed = TRUE    # ensures parallel RNG is valid
  )
  
  final_df <- do.call(rbind, sim_list)
  final_df$teams <- teams
  
  assign(key, final_df, envir = .GlobalEnv)
  
  # UPDATE BLOCK-LEVEL PROGRESS BAR
  p_block()
  
  message("Finished: ", key)
}


with_progress({
  p_block <- progressor(steps = nrow(round_robin_param_grid))
  
  for (i in seq_len(nrow(round_robin_param_grid))) {
    row <- round_robin_param_grid[i, ]
    
    round_robin_run_sim_block(
      teams        = teams,
      distribution = row$distribution,
      ties         = row$ties,
      r            = row$r,
      p_block = p_block
    )
  }
})
```

## Group Stage

```{r}
# Group stage is currently set so only the top 2 in each group advance
group_stage_param_grid <- expand.grid( 
  distribution = c("Normal","Uniform", "Same"), 
  ties = c(FALSE, TRUE), 
  rounds = c(1,2,4),
  group_length = c(4,8)
  )

group_stage_run_sim_block <- function(
  teams, distribution, ties, rounds, group_length, p_block) {

  # Build key
    # Build the key
  parts <- c(
    "groupStage",
    tolower(distribution),
    ifelse(ties, "ties", "noTies"),
    paste0(rounds),
    paste0(group_length, "groups")
  )

  key <- paste(parts, collapse = "_")
  
  # Run 10,000 simulations in parallel
  sim_list <- future_lapply(
    X = 1:10000,
    FUN = function(rep) {
      simulate_group_stage_tournament(
        num_teams = teams,
        distribution = distribution,
        ties = ties,
        rounds = rounds,
        group_length = group_length
      )
    },
    future.seed = TRUE    # ensures parallel RNG is valid
  )
  
  final_df <- do.call(rbind, sim_list)
  final_df$teams <- teams
  
  assign(key, final_df, envir = .GlobalEnv)
  
  # UPDATE BLOCK-LEVEL PROGRESS BAR
  p_block()
  
  message("Finished: ", key)
}


with_progress({
  p_block <- progressor(steps = nrow(group_stage_param_grid))
  
  for (i in seq_len(nrow(group_stage_param_grid))) {
    row <- group_stage_param_grid[i, ]
    
    group_stage_run_sim_block(
      teams        = teams,
      distribution = row$distribution,
      ties         = row$ties,
      rounds       = row$rounds,
      group_length = row$group_length,
      p_block = p_block
    )
  }
})

```

## Waterfall

## Step Ladder

```{r}
stepLadder_param_grid <- expand.grid( 
  distribution = c("Normal","Uniform", "Same"), 
  series = c(1, 3, 7), 
  bad_seeding_structure = c(FALSE, TRUE) 
  )

stepLadder_run_sim_block <- function(
  teams, distribution, bad_seeding_structure, series, p_block) {
  
  # Apply bad seeding structure override if required
  seeding_structure <- if (bad_seeding_structure) 1:16 else NULL

  # Build key
    # Build the key
  parts <- c(
    "stepLadder",
    tolower(distribution),
    paste0(series),
    if (bad_seeding_structure) "badseed"
    
  )

  key <- paste(parts, collapse = "_")
  
  # Run 10,000 simulations in parallel
  sim_list <- future_lapply(
    X = 1:10000,
    FUN = function(rep) {
      simulate_step_ladder(
        num_teams = teams,
        distribution = distribution,
        series = series,
        seeding_structure = seeding_structure
      )
    },
    future.seed = TRUE    # ensures parallel RNG is valid
  )
  
  final_df <- do.call(rbind, sim_list)
  final_df$teams <- teams
  
  assign(key, final_df, envir = .GlobalEnv)
  
  # UPDATE BLOCK-LEVEL PROGRESS BAR
  p_block()
  
  message("Finished: ", key)
}


with_progress({
  p_block <- progressor(steps = nrow(stepLadder_param_grid))
  
  for (i in seq_len(nrow(stepLadder_param_grid))) {
    row <- stepLadder_param_grid[i, ]
    
    stepLadder_run_sim_block(
      teams        = teams,
      distribution = row$distribution,
      series       = row$series,
      bad_seeding_structure = row$bad_seeding_structure,
      p_block = p_block
    )
  }
})
```

## Staged Round Robin

## High School Tennis Ladder

# Getting Mutual Information

### Functions to get MI and put it in a Data Frame for Plots

```{r}
library(ggsci)
compute_mi_for_datasets <- function(dataset_list) {
  # Validate input
  if (!is.list(dataset_list)) {
    stop("dataset_list must be a list of data frames")
  }
  
  # Get dataset names from the list
  if (!is.null(names(dataset_list)) && all(names(dataset_list) != "")) {
    dataset_names <- names(dataset_list)
  } else {
    dataset_names <- paste0("Dataset_", seq_along(dataset_list))
  }
  
  # Helper function to add simulation number if needed
  add_simulation_number <- function(df) {
    if (!"simulation" %in% colnames(df)) {
      n_rows <- nrow(df)
      n_sims <- 10000
      rows_per_sim <- round(n_rows / n_sims)
      
      # Memory efficient: create simulation numbers
      df$simulation <- rep(1:n_sims, each = rows_per_sim)
    }
    return(df)
  }
  
  # Compute MI for all datasets and store as list column
  mi_list <- lapply(seq_along(dataset_list), function(i) {
    df <- dataset_list[[i]]
    df <- add_simulation_number(df)
    
    # Compute MI - returns a vector or dataframe
    result <- compute_mut_plots(df)
    
    # Convert to vector if it's a dataframe
    if (is.data.frame(result)) {
      result <- unlist(result)
    }
    
    return(result)
  })
  
  # Return dataframe with list column
  data.frame(
    dataset = dataset_names,
    stringsAsFactors = FALSE
  ) %>%
    mutate(mi = mi_list)
}

# Example usage:
mi_ex <- compute_mi_for_datasets(list(
   singleElimination_normal_noTies_1,
   singleElimination_normal_noTies_1_badseed
 ))
 

plot_mi <- function(mi_results, dataset_names = NULL) {
  # If no dataset names specified, plot all datasets
  if (is.null(dataset_names)) {
    dataset_names <- mi_results$dataset
  }
  
  # Filter to only requested datasets
  filtered_results <- mi_results %>%
    filter(dataset %in% dataset_names)
  
  if (nrow(filtered_results) == 0) {
    stop("No matching datasets found in results.")
  }
  
  # Convert list column to long format for plotting
  plot_df <- filtered_results %>%
    rowwise() %>%
    mutate(
      index = list(1:length(mi)),
      mi_values = list(mi)
    ) %>%
    unnest(cols = c(index, mi_values)) %>%
    ungroup()
  
  return(plot_df)
}
```

### Getting MI for All Structures

```{r}
compute_and_store_mi_by_tournament <- function(tournament_structure) {
  
  # Validate input
  valid_structures <- c("singleElimination", "doubleElimination", "roundRobin", "groupStage", "stepLadder")
  if (!tournament_structure %in% valid_structures) {
    stop(paste("Invalid tournament_structure. Must be one of:", 
               paste(valid_structures, collapse = ", ")))
  }
  
  # Helper function to collect datasets for a specific tournament type
  collect_tournament_datasets <- function(param_grid, tournament_type, key_builder) {
    dataset_list <- list()
    
    for (i in seq_len(nrow(param_grid))) {
      row <- param_grid[i, ]
      parts <- key_builder(row, tournament_type)
      key <- paste(parts, collapse = "_")
      
      if (exists(key, envir = .GlobalEnv)) {
        dataset_list[[key]] <- get(key, envir = .GlobalEnv)
      } else {
        warning(paste("Dataset not found:", key))
      }
    }
    
    return(dataset_list)
  }
  
  # Key builders for each tournament type
  single_elim_key <- function(row, type) {
    c(
      type,
      tolower(row$distribution),
      ifelse(row$ties, "ties", "noTies"),
      paste0(row$series),
      if (row$third_place) "thirdplace",
      if (row$reseeded) "reseeded",
      if (row$bad_seeding_structure) "badseed"
    )
  }
  
  double_elim_key <- function(row, type) {
    c(
      type,
      tolower(row$distribution),
      ifelse(row$ties, "ties", "noTies"),
      paste0(row$series),
      if (!row$final) "consolation",
      if (row$bad_seeding_structure) "badseed"
    )
  }
  
  round_robin_key <- function(row, type) {
    c(
      type,
      tolower(row$distribution),
      ifelse(row$ties, "ties", "noTies"),
      paste0(row$r)
    )
  }
  
  group_stage_key <- function(row, type) {
    c(
      type,
      tolower(row$distribution),
      ifelse(row$ties, "ties", "noTies"),
      paste0(row$rounds),
      paste0(row$group_length, "groups")
    )
  }
  
   stepLadder_key <- function(row, type) {
    c(
    type,
    tolower(row$distribution),
    paste0(row$series),
    if (row$bad_seeding_structure) "badseed"
    )
   }
   
  
  # Function to process a single tournament type
  process_tournament_type <- function(type_name, param_grid, key_builder) {
    message(paste("Collecting", type_name, "datasets..."))
    datasets <- collect_tournament_datasets(param_grid, type_name, key_builder)
    
    message(paste("Computing MI for", type_name, "..."))
    mi_results <- compute_mi_for_datasets(datasets)
    
    # Store in global environment
    mi_var_name <- paste0(type_name, "_mi")
    assign(mi_var_name, mi_results, envir = .GlobalEnv)
    
    # Create summary
    summary_df <- data.frame(
      dataset = names(mi_results),
      mi = mi_results,
      stringsAsFactors = FALSE
    )
    
    message(paste("- Created", mi_var_name, "with", length(mi_results), "datasets"))
    
    return(list(mi = mi_results, summary = summary_df))
  }
  
  # Process based on tournament_structure input
  results_list <- list()
  summary_list <- list()
  
  if (tournament_structure %in% c("singleElimination")) {
    result <- process_tournament_type("singleElimination", 
                                      single_elimination_param_grid, 
                                      single_elim_key)
    results_list$singleElimination <- result$mi
    summary_list$singleElimination <- result$summary
  }
  
  if (tournament_structure %in% c("doubleElimination")) {
    result <- process_tournament_type("doubleElimination", 
                                      double_elimination_param_grid, 
                                      double_elim_key)
    results_list$doubleElimination <- result$mi
    summary_list$doubleElimination <- result$summary
  }
  
  if (tournament_structure %in% c("roundRobin")) {
    result <- process_tournament_type("roundRobin", 
                                      round_robin_param_grid, 
                                      round_robin_key)
    results_list$roundRobin <- result$mi
    summary_list$roundRobin <- result$summary
  }
  
  if (tournament_structure %in% c("groupStage")) {
    result <- process_tournament_type("groupStage", 
                                      group_stage_param_grid, 
                                      group_stage_key)
    results_list$groupStage <- result$mi
    summary_list$groupStage <- result$summary
  }
   if (tournament_structure %in% c("stepLadder")) {
    result <- process_tournament_type("stepLadder", 
                                      stepLadder_param_grid, 
                                      stepLadder_key)
    results_list$stepLadder <- result$mi
    summary_list$stepLadder <- result$summary
  }
  
  message("\nâœ“ MI computation complete!")
  
  # Return a list of all results (optional)
  invisible(results_list)
}

compute_and_store_mi_by_tournament("groupStage")


all_mi <- bind_rows(
  singleElimination_mi,
  doubleElimination_mi,
  groupStage_mi,
  roundRobin_mi,
  stepLadder_mi
)
```

## MI Plots

```{r}
# Example Plot for Round Robin
roundRobin_plot_df <- plot_mi(roundRobin_mi)

ggplot(roundRobin_plot_df, aes(x = index, y = mi_values, color = dataset, group = dataset)) +
    geom_line(linewidth = 1) +
    geom_point(size = 2) +
    labs(
      title = "Mutual Information Round Robin Comparison",
      x = "Top K Teams",
      y = "Mutual Information (MI)",
      color = "Dataset"
    ) +
    scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
    scale_x_continuous(breaks = 1:max(roundRobin_plot_df$index)) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.position = "bottom",
      legend.title = element_text(size = 11, face = "bold"),
      legend.text = element_text(size = 9)
    ) +
    scale_color_d3("category20")


normal_plot_df <- plot_mi(all_mi, c("singleElimination_normal_noTies_1", "doubleElimination_normal_noTies_1", "roundRobin_normal_noTies_1", "groupStage_normal_noTies_1_4groups", "stepLadder_normal_1"))

ggplot(normal_plot_df, aes(x = index, y = mi_values, color = dataset, group = dataset)) +
    geom_line(linewidth = 1) +
    geom_point(size = 2) +
    labs(
      title = "Mutual Information Normal Comparison",
      x = "Top K Teams",
      y = "Mutual Information (MI)",
      color = "Dataset"
    ) +
    scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
    scale_x_continuous(breaks = 1:max(normal_plot_df$index)) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.position = "right",
      legend.title = element_text(size = 11, face = "bold"),
      legend.text = element_text(size = 9)
    ) +
    scale_color_d3("category20")

unif_plot_df <- plot_mi(all_mi, c("singleElimination_uniform_noTies_1", "doubleElimination_uniform_noTies_1", "roundRobin_uniform_noTies_1", "groupStage_uniform_noTies_1_4groups", "stepLadder_uniform_1"))

ggplot(unif_plot_df, aes(x = index, y = mi_values, color = dataset, group = dataset)) +
    geom_line(linewidth = 1) +
    geom_point(size = 2) +
    labs(
      title = "Mutual Information Uniform Comparison",
      x = "Top K Teams",
      y = "Mutual Information (MI)",
      color = "Dataset"
    ) +
    scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
    scale_x_continuous(breaks = 1:max(unif_plot_df$index)) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.position = "right",
      legend.title = element_text(size = 11, face = "bold"),
      legend.text = element_text(size = 9)
    ) +
    scale_color_d3("category20")



```
